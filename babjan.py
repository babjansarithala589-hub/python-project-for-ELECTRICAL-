# -*- coding: utf-8 -*-
"""babjan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ybil_2JNhPY1Phk5A1dr-ShJ-rnVT7Mr
"""

class student:
  def init_(self,name,roll_no,marks):
    self.name=name
    self.rollno=roll_no
    self.marks=marks
    s1=student("Alice",101,88)
    print(s1.name,s1.roll_no,s1.marks)

text="python is fun"
print(text.split ())
print(text[0:6])

class Beam:
  def _init_(self,load,length,E,I):
    self.laod=load
    self.length=length
    self.E=E
    self.I=I
  def deflection(self):
    return(self.load*self.length**3)/(48*self.E*self.I)
    beam1=Beam(1000,2,2e11,Be-6)
    print("Deflection:",round(beam1.deflection(),6),"m")

class structure:
  def _init_(self,length,load_per_m):
    self.length=length
    self.load_per_m=load_per_m
  def totalload(self):
    return self.load*self.load_per_m
    class Bridge(structure):
      def _init_(self,length,load_per_m,lanes):
        super()._init_(length,load_per_m)
        self.lanes=lanes
        def total_lane_load(self):
          return self.total_load()*self.lanes
          bridge=Bridge(100,5,4)
          print("Total load on bridge:",bridge.total_lane_load(),"kN")

from typing import Generator
class Machine:
  def efficiency(self):
    return "Efficiency not defined"
    class Motor(Machine):
      def efficiency(self):
        return "Motor Efficiency: 90%"
        class Generator(Machine):
          def efficiency(self):
            return "Generator Efficiency: 85%"
            machines=[Motor(),Generator()]
            for m in machines:
              print(m.efficiency())

import csv
  data=[["Time(s)","Voltage(v)"],[0,0],[1,5],[2,9]]
  with open("lab_data.csv","w",newline="")as f:
    writer=csv.writer(f)
    writer.writerows(data)
    with open("lab_data.csv","r")as f:
      reader=csv.reader(f)
      for row in reader:
        print(row)

import numpy as np
forces=np.array([10,20,30])
lengths=np.array([2,4,6])
moments=forces*lengths
print("Movement:",moments)

import pandas as pd
df=pd.Dataframes({
    "Beam ID":["B1","B2"],
    "Length(m)":[5,6],
    "Load per m (kN/m)":[10,12]
    })
df ["Total Load"]=df["Length(m)"]*df["Load per m (kN/m)"]
print(df)

import matplotlib.pyplot as plt
stress=[0,50,100,150,200]
strain=[0,0.002,0.004,0.006,0.008]
plt.plot(strain,stress,marker='0')
plt.xlabel("strain")
plt.ylabel("stress(mpa)")
plt.title("stress-strain curve")
plt.show()

import math
def rlc_impedence(R,L,C,F):
  xl=2*math.pi*F*l
  xc=1/( 2*math.pi*F*C)
  return math.sqrt(R**2+(x1-xc)**2)
  R=100
  L=0.5
  C=1e-6
  f=50
  print("RlC circuit Impedence:",rlc_impedence(R,L,C,f),"ohm")

import math
def three_phase_power(v_line,l_line,power_factor):
  return math.sqrt(3)* v_line*l_line* power_factor
  print("Three-phase power:",three_phase_power(415,10,0.9),"watts)"

import math
print("Circle Area:",math.pi*.7**5)

beam_id="B12"
length_m=5.5
is_safe=True
matrial=["steel","concrete"]

density=5790
volume=0.006
mass=density*volume
print("Mass(kg):",mass)

stress=250
if stress>300:
  print("fail")
elif stress>250:
  print("Near Failure")
else:
  print("safe")

for load in[100,300,400]:
  print("Load:",load)
  count=0
  while count<9:
    print("count:",count)
    count+=1

def beam_volume(l,b,h):
  return l*b*h
  print("volume:",beam_volume(6,.8,.6))

class concereteslab:
  def _init_(self,length,width,height):
    self.length=length
    self.width=width
    self.height=height
  def volume(self):
    return self.length*self.width*self.height
    def volume(self):
      return self l*self.b*self

class motor:
  def_init_(self,power_kw,efficiency):
    self.power_kw=power_kw
    self.efficiency = efficiency

import numpy as np
list=np.array([1,4,6])
print(list)

import numpy as np
list=np.array([[1,2,3],[4,5,6]])
print(list)

import numpy as np
set=np.array([3,5,7])
print(set)

import numpy as np
dict=np.array([3,5,7])
print(dict)

import numpy as np
import matplotlib.pyplot as plt

class LiionBattery:
    def __init__(self, capacity_Ah, initial_soc, voltage_V, charging_efficiency=0.95, discharging_efficiency=0.95):
        if not 0 <= initial_soc <= 1:
            raise ValueError("Initial SOC must be between 0 and 1")
        self.capacity_Ah = capacity_Ah
        self.soc = initial_soc
        self.voltage_V = voltage_V
        self.charging_efficiency = charging_efficiency
        self.discharging_efficiency = discharging_efficiency

    def update_soc(self, current_A, time_step_h):
        """Updates the battery's state of charge."""
        if current_A > 0:  # Charging
            charge_change_Ah = current_A * time_step_h * self.charging_efficiency
        else:  # Discharging
            charge_change_Ah = current_A * time_step_h / self.discharging_efficiency

        self.soc += charge_change_Ah / self.capacity_Ah
        self.soc = max(0, min(1, self.soc)) # Ensure SOC stays within [0, 1]


    def get_current_voltage(self):
        """Returns the current voltage (simplified model assumes constant voltage)."""
        return self.voltage_V

    def calculate_efficiency(self, current_A):
        """Calculates efficiency based on current (simplified model assumes constant efficiency)."""
        if current_A > 0: # Charging
            return self.charging_efficiency
        elif current_A < 0: # Discharging
            return self.discharging_efficiency
        else: # No current
            return 1.0

# 1. Define the total simulation time and the time step
total_time_h = 10  # Total simulation time in hours
time_step_h = 0.1  # Time step in hours
num_steps = int(total_time_h / time_step_h)

# 2. Create an instance of the LiionBattery class
battery = LiionBattery(capacity_Ah=50, initial_soc=0.5, voltage_V=350)

# 3. Initialize lists to store simulation results
time_list = []
soc_list = []
current_list = []
voltage_list = []
efficiency_list = []

# 4. Loop through the simulation time
for i in range(num_steps):
    current_time = i * time_step_h

    # Define the current at the current time step
    # Example: Charging for the first half, discharging for the second half
    if current_time < total_time_h / 2:
        current_A = 20  # Charging current
    else:
        current_A = -15  # Discharging current


    # Update the battery's state
    battery.update_soc(current_A, time_step_h)
    current_voltage = battery.get_current_voltage()
    current_efficiency = battery.calculate_efficiency(current_A)

    # Append results to lists
    time_list.append(current_time)
    soc_list.append(battery.soc)
    current_list.append(current_A)
    voltage_list.append(current_voltage)
    efficiency_list.append(current_efficiency)

# Create a figure and a set of subplots
fig, axes = plt.subplots(2, 1, figsize=(10, 8))

# Plot SOC over time
axes[0].plot(time_list, soc_list)
axes[0].set_xlabel('Time (h)')
axes[0].set_ylabel('State of Charge (SOC)')
axes[0].set_title('Battery State of Charge over Time')

# Plot efficiency over time
axes[1].plot(time_list, efficiency_list)
axes[1].set_xlabel('Time (h)')
axes[1].set_ylabel('Efficiency')
axes[1].set_title('Battery Efficiency over Time')

# Adjust layout and display plots
plt.tight_layout()
plt.show()

import numpy as np
list=np.array([1,4,6])
print(list)

import numpy as np
list=np.array([[1,2,3],[4,5,6]])
print(list)

import numpy as np
dict=np.array([3,5,7])
print(dict)

import numpy as np
set=np.array([3,5,7])
print(set)

from typing import Generator
class Machine:
  def efficiency(self):
    return "Efficiency not defined"
    class Motor(Machine):
      def efficiency(self):
        return "Motor Efficiency: 90%"
        class Generator(Machine):
          def efficiency(self):
            return "Generator Efficiency: 85%"
            machines=[Motor(),Generator()]
            for m in machines:
              print(m.efficiency())

class structure:
  def _init_(self,length,load_per_m):
    self.length=length
    self.load_per_m=load_per_m
  def totalload(self):
    return self.load*self.load_per_m
    class Bridge(structure):
      def _init_(self,length,load_per_m,lanes):
        super()._init_(length,load_per_m)
        self.lanes=lanes
        def total_lane_load(self):
          return self.total_load()*self.lanes
          bridge=Bridge(100,5,4)
          print("Total load on bridge:",bridge.total_lane_load(),"kN")

class Beam:
  def _init_(self,load,length,E,I):
    self.laod=load
    self.length=length
    self.E=E
    self.I=I
  def deflection(self):
    return(self.load*self.length**3)/(48*self.E*self.I)
    beam1=Beam(1000,2,2e11,Be-6)
    print("Deflection:",round(beam1.deflection(),6),"m")

class student:
  def init_(self,name,roll_no,marks):
    self.name=name
    self.rollno=roll_no
    self.marks=marks
    s1=student("Alice",101,88)
    print(s1.name,s1.roll_no,s1.marks)

